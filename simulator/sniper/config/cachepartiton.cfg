
[general]
enable_icache_modeling = true

## Core

[perf_model/core]
frequency = 3
logical_cpus = 1
type = rob
core_model = nehalem

[perf_model/core/interval_timer]
window_size = 128
dispatch_width = 4
issue_memops_at_dispatch = true

[perf_model/core/rob_timer]
outstanding_loads = 48
outstanding_stores = 32
commit_width = 4              # Commit bandwidth (instructions per cycle), per SMT thread
rs_entries = 36

in_order = false
issue_contention = true
mlp_histogram = false           # Collect histogram of memory-level parallelism (slow)
issue_memops_at_issue = true    # Issue memops to the memory hierarchy at issue time (false = before dispatch)
store_to_load_forwarding = true # Forward data to loads from stores that are still in the store buffer
address_disambiguation = true   # Allow loads to bypass preceding stores with an unknown address
rob_repartition = false


## Network

[network]
system_model = "emesh_hop_by_hop"
memory_model_1 = "emesh_hop_by_hop"
collect_traffic_matrix = "true"

[network/bus]
ignore_local_traffic = "true"

[network/emesh_hop_by_hop]
concentration = 1
dimensions = 1
hop_latency = 2
link_bandwidth = 64
size = ""
wrap_around = "true"

[network/emesh_hop_by_hop/broadcast_tree]
enabled = "false"

[network/emesh_hop_by_hop/queue_model]
enabled = "true"
type = "history_list"

## Caches

[perf_model/l1_icache]
address_hash = "mask"
shared_cores = 1
cache_size = 32
associativity = 4
outstanding_misses = 8
replacement_policy = "lru"
perf_model_type = parallel
writethrough = 0
dvfs_domain = core
tags_access_time = 1
data_access_time = 1
cache_block_size = 64
perfect = "false"

[perf_model/l1_dcache]
address_hash = "mask"
shared_cores = 1
cache_size = 32
associativity = 8
outstanding_misses = 8
replacement_policy = "lru"
perf_model_type = parallel
writethrough = 0
dvfs_domain = core
tags_access_time = 1
data_access_time = 2
cache_block_size = 64
perfect = "false"

[perf_model/l2_cache]
address_hash = "mask"
shared_cores = 1
cache_size = 128
associativity = 8
outstanding_misses = 12
replacement_policy = "lru"
perf_model_type = parallel
writeback_time = 25
writethrough = 0
dvfs_domain = core
tags_access_time = 1
data_access_time = 2
cache_block_size = 64
perfect = "false"

[perf_model/l3_cache]
address_hash = "mask"
shared_cores = 32
replacement_policy = "lru"
cache_size = 4096
associativity = 32
outstanding_misses = 24
perf_model_type = parallel
writeback_time = 50
tags_access_time = 4
data_access_time = 19
perfect = "false"
writethrough = 0
dvfs_domain = core
prefetcher = none
cache_block_size = 64

[perf_model/l3_cache/umon]
enabled = false
sampling = "count"
sample_sets = 32                # Sets per core
reallocate_period = 5000000     # In cycles
enable_stream_detection = false
stream_miss_count_limit = 2048
stream_miss_fraction_limit = 0.125

[perf_model/l3_cache/drrip]
bits=4

[perf_model/cache]
levels = 3

## TLBs 

[perf_model/tlb]
penalty = 30          # Page walk penalty in cycles

[perf_model/itlb]
size = 128            # Number of I-TLB entries
associativity = 4     # I-TLB associativity

[perf_model/dtlb]
size = 64             # Number of D-TLB entries
associativity = 4     # D-TLB associativity

[perf_model/stlb]
size = 1024           # Number of second-level TLB entries
associativity = 8     # S-TLB associativity

## DRAM

[perf_model/dram/cache]
enabled = false

[perf_model/dram/queue_model]
enabled = "true"
#type = "history_list"
type = "contention"

[perf_model/dram]
num_controllers = 1
latency = 45
per_controller_bandwidth = 12.8
direct_access = false

[perf_model/dram_directory]
total_entries = 4194304 # set based on gainestown.cfg, should be enought to cover 16MB caches
associativity = 32
directory_type = full_map

[network]
memory_model_1 = bus
memory_model_2 = bus

[network/bus]
bandwidth = 25.6 # in GB/s. Actually, it's 12.8 GB/s per direction and per connected chip pair
ignore_local_traffic = true # Memory controllers are on-chip, so traffic from core0 to dram0 does not use the QPI links