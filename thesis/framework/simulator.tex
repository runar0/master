\section{Simulator}
\label{sec:framework:simulator}

There are several different simulators used in computer architecture research today~\cite{Carlson2011a, Binkert2011, Miller2010, Pellauer2011}.
Of the simulators used today, we evaluated two possible candidates for this work, Sniper~\cite{Carlson2011a} and gem5~\cite{Binkert2011}.
These two candidates are mainly chosen because they are both in active use by the CARD~\cite{CARD2015} research group at NTNU where this thesis is performed.
Gem5 is also an obvious candidate because it is the simulator used in most computer architecture research today~\cite{Chen-Han2014}.
It is a cycle accurate simulator meaning that it can theoretically simulate real hardware perfectly.
This accuracy comes at the cost of simulation time.
The other candidate, Sniper, is based on interval simuation~\cite{Genbrugge2010}. 
Interval simulation allows it to simulate benchmarks significantly faster than gem5~\cite{Carlson2011a, Olsen2014} at the cost of reduced accuracy.

Sniper is multithreaded, and each simulated core runs in a separate simulation thread.
This separation allows Sniper to take advantage of today's multicore processors to speed up the simulation.
On the other hand, gem5 performs all simulation in a single thread.
By having multiple simulation threads, there is a chance of clock skewing~\cite{Carlson2011a} during simulations in Sniper.
Clock skewing is when one core simulates faster or slower than the others, making the clock values in each core different.
When this happens, the simulator cannot correctly simulate inter-core interactions, such as access to the shared cache.
There are however techniques implemented in Sniper that attempt to reduce errors caused by clock skewing.

Gem5 is an execution-driven simulator. 
It takes the benchmark binary as input and simulates it by correctly executing instructions like a real processor.
Sniper, which is trace-driven, does not need the benchmark binary, but rather a trace of instructions from a previous run.
The instruction trace is generated by running the benchmark ahead of time, and dumping committed instructions as the benchmark progresses.
As a result, the instruction trace does not contain instructions that were executed along miss-predicted execution paths and later reverted.
Because of this, Sniper cannot correctly estimate the cost of a branch miss prediction, as this may vary depending on the effect of the wrongly executed instructions.
Gem5 will execute the wrong execution path just like a real processor, and hence correctly estimates this penalty.
By using traces, Sniper does not have to simulate the effect of each instruction correctly, it only needs to estimate the time it will take to execute.
This makes the simulator code base smaller, and it becomes easier to extend it with new algorithms.

Based the authors previous work~\cite{Olsen2014}, we chose Sniper over gem5 because the simplicity and speed of Sniper outweigh the reduced accuracy compared to gem5.
Because we know that clock skewing in Sniper might be an issue for our work, we will perform an experiment investigating this error source further in Section~\ref{sec:results:csmb_sensitivity}.