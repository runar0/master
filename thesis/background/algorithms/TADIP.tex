\subsection{TADIP}
\label{sec:background:algorithms:tadip}

Thread Aware Dynamic Insertion Policy (TADIP)~\cite{Jaleel2008} proposed by A. Jaleel et al. in 2008 is an extension of DIP~\cite{Qureshi2007} originally proposed by M. K. Qureshi in 2007.
In the following paragraphs, we will first present DIP and then present the additions needed to make DIP perform well for shared caches.

\paragraph{DIP}

The DIP algorithm views the cache set as a stack, as in LRU.
On a cache miss, DIP evicts the block at the LRU position. 
In contrast to LRU, DIP is a combination of two insertion policies, the standard LRU insertion policy (LIP) and Binominal Insertion Policy (BIP).
LIP inserts new blocks at the MRU position.
BIP inserts new blocks either at the LRU position or with a small probability, $p = \frac{1}{32}$, at the MRU position. The overall DIP algorithm switches between the two insertion policies by always using the one that is expected to cause fewer cache misses.

By mostly inserting at the LRU position the BIP insertion policy can theoretically handle trashing memory access patterns.
BIP inserts most of the new blocks in the LRU position, and the upper part of the LRU stack is reserved for blocks that have been re-referenced.
In a trashing access pattern, this results in part of the working set residing in the upper part of the stack while rest is inserted at the LRU position and evicted at the next miss.
By sometimes inserting at the MRU position BIP will give blocks not referenced by the next miss a chance to stay in the cache. 
This will also force stale cache blocks in the upper part of the stack to move towards the LRU position.

The authors of DIP present several methods to detect the best replacement algorithm. 
One such technique is called set-dueling.
Set-dueling is implemented by having some sets of the cache use either BIP or LRU. 
A counter tracks the performance of the dueling sets.
Misses in LRU sets will increment the counter and misses in BIP sets will decrement the counter.
The MSB of the counter can then be used to select the optimal algorithm.
If the MSB is one, an overweight of misses in LRU sets are occurring and BIP the optimal algorithm. 
If the MSB is zero, then an overweight of BIP misses are occurring, and LRU is the optimal choice.
Another solution is to utilize two Auxilliary Tag Directories (ATDs) which is a structure equal to the Tag directory of the cache itself.
The two ATDs run one algorithm each, and all cache accesses are also executed on the ATDs.
Again a counter controlled by misses in either ATD is used to select the optimal algorithm for the main cache.

\paragraph{TADIP}

One issue with DIP is that it does not consider from which core a cache accesses originate.
In a workload with multiple benchmarks, some might be recency-friendly while others are not. 
If a shared cache is managed by DIP, then the algorithm choice is made based on the sum of the cache accesses and then applied equally to all benchmarks.
The authors of TADIP recognized that improvements in performance could be achieved by selecting DIP algorithm on a per core basis when utilized on a shared cache.

When selecting the best performing algorithm per core, the ATD technique requires two ATDs per core sharing the cache. 
This quickly becomes too expensive to be practical.
Set-dueling in DIP requires a minimum of two sets, one running LRU (1) and one running BIP (0). 
With two cores, the number of combinations rises to four (00, 01, 10, 11).
When the number of cores continues to increase this also seems to be an impractical solution.
As a result, the authors of TADIP suggests two selection techniques that reduce the number of sets required. 
Both solutions have one counter per core sharing the cache.
This counter is used to select the optimal policy for that core.

TADIP-Isolated (TADIP-I) has one set per core running BIP for that core and LRU for all others.
In addition to these N sets, a single set runs LRU for all cores. 
A miss in the LRU set will increment all the core counters while a miss in the core specific set will decrement the counter for the specific core.
For a large N, this solution requires significantly less duel-sets compared to having one per combination. 
Because it assumes that all other cores run LRU, the effect different cores with different policies might have on each other is ignored.

TADIP-Feeback (TADIP-F) attempts to reduce the error caused by the assumption of other cores by having two sets per core, a total of 2N.
Per core, one set runs LRU the other runs BIP, any inserts from other cores uses the currently best algorithm for that core.
A miss in the LRU set for a core will increment that cores counter, a miss the BIP set will decrement the counter.

\todo{Create an illustration like the one in the TADIP paper!}

Figure~\todo{ref} shows an illustration of a cache managed by DIP, TADIP-I, and TADIP-F. 
As is shown the duel-sets effect a set of counters, these counters give the optimal policy, P, per core. 
The remaining sets use the set of current optimal replacement policies.
From this point on when we refer to TADIP in this report we assume TADIP-F unless otherwise stated.

When detailing their implementation, the authors of TADIP show a simple hash function used to select dueling sets.
On their 4096 set cache, they use the formulas shown below.
Here set index is a number from 0-4095, core\_id is the zero-indexed id of the requester core and cores is the total number of cores sharing the cache.
If BIP or LIP is true, then the set is a duel set for the given core, and the policy forced to either BIP or LIP.
If both BIP and LIP is false, then the set is a normal follower set and utilized the current best algorithm for the given core.
From the algorithm, it is clear that the original paper use a total of 32 groups of duel sets spread evenly throughout the cache.
\begin{figure*}[ht]
\begin{equation}
LIP = set\_no[11:7] + core\_id == set\_no[6:0]
\end{equation}
\begin{equation}
BIP = set\_no[11:7] + core\_id + cores == set\_no[6:0]
\end{equation}
\begin{equation}
FOLLOWER = !LIP + !BIP
\end{equation}
\end{figure*}

\todo{We should run an experiment finding the best binomial parameter for our workloads, also we need to find the optimal number of duel sets. The original paper chooses 1/32, compare this to our result. How is this experiment best executed? Does using only 4-benchmark workloads approximate or should we also use 8- and 16-benchmakr workloads? If so we have to create them.}